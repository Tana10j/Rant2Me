<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="images/Rant2Me Favicon.png">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Therapy Chat ‚Äî Tana</title>
  <link rel="stylesheet" href="chat-style.css" />
</head>
<body>
<button onclick="window.location.href='home.html'" class="home-btn">üè† Home</button>
  <div class="chat-container">
    <div class="chat-header">Chat with Tana (Therapist)</div>

    <div class="chat-messages" id="chat-box">
      <div class="message bot">
        <img src="assets/avatars/Tana.png" class="avatar" />
        <div class="bubble">Hello ‚Äî I'm Tana, a professional listener. Penny for your thoughts?</div>
      </div>
    </div>

    <div class="chat-input">
      <input type="text" id="userInput" placeholder="Type your message..." />
      <button id="sendBtn">Send</button>
    </div>
  </div>

<script type="module">
  import { auth, db } from './firebase.js';
  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
  import {
    collection, addDoc, serverTimestamp,
    query, orderBy, onSnapshot, doc, setDoc, getDoc
  } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

  const SECTION = "counselling";
  const ADMIN_NAME = "Tana";

  const chatBox = document.getElementById('chat-box');
  const input = document.getElementById('userInput');
  const sendBtn = document.getElementById('sendBtn');

  let currentUid = null;
  let messagesColRef = null;
  let unsubscribeSnapshot = null;
  let unsubscribeEnt = null;

  onAuthStateChanged(auth, async (user) => {
    if (!user) { window.location.href = "index.html"; return; }
    currentUid = user.uid;

    // === Access guard ===
    const ok = await hasAccess(currentUid, SECTION);
    if (!ok) {
      alert("Please purchase a plan to access this chat.");
      window.location.href = "pay.html#counselling";
      return;
    }

    // Start an expiry watcher; if it expires while open, lock UI & redirect
    unsubscribeEnt = watchExpiry(currentUid, SECTION);

    initRealtimeListenerForUser(currentUid);
  });

  // IMPORTANT: entitlementId must be "<section>_<uid>"
  async function hasAccess(uid, section) {
    try {
      const entRef = doc(db, "entitlements", `${section}_${uid}`);
      const entSnap = await getDoc(entRef);
      if (!entSnap.exists()) return false;
      const d = entSnap.data();
      // Accept only if status active and expiresAt in future
      if (d.status !== "active") return false;
      if (!d.expiresAt || typeof d.expiresAt.toMillis !== "function") return false;
      return d.expiresAt.toMillis() > Date.now();
    } catch (err) {
      console.warn("hasAccess() entitlement read failed:", err);
      return false;
    }
  }

  /**
   * watchExpiry:
   * - attaches onSnapshot (fast notifications when the server updates the doc)
   * - also sets up a small interval (5s) that reads the document (poll) and
   *   checks wall-clock expiry. This ensures the page detects expiry even
   *   when no server write happens exactly at the expiry time.
   *
   * Returns an unsubscribe function that clears both the listener and the interval.
   */
  function watchExpiry(uid, section) {
    try {
      const entRef = doc(db, "entitlements", `${section}_${uid}`);
      let timedOut = false;
      let lastData = null;

      // Immediate onSnapshot (fires with current document)
      const unsubSnap = onSnapshot(entRef, (snap) => {
        if (!snap.exists()) {
          lastData = null;
          return;
        }
        lastData = snap.data();
        evaluateAndMaybeExpire();
      }, (err) => {
        console.error("watchExpiry onSnapshot error:", err);
      });

      // Poll fallback - check every 5s to detect expiry by comparing wall clock
      const pollMs = 5000;
      const poll = setInterval(async () => {
        if (timedOut) return;
        try {
          const snap = await getDoc(entRef);
          if (!snap.exists()) {
            lastData = null;
            return;
          }
          lastData = snap.data();
          evaluateAndMaybeExpire();
        } catch (err) {
          console.error('watchExpiry poll getDoc error:', err);
        }
      }, pollMs);

      // helper to check lastData's expiry & act
      function evaluateAndMaybeExpire() {
        if (!lastData) return;
        const now = Date.now();
        const expiresAt = lastData.expiresAt;
        const expiresMs = expiresAt && typeof expiresAt.toMillis === "function" ? expiresAt.toMillis() : null;
        const active = lastData.status === "active";

        if (!active || (expiresMs !== null && expiresMs <= now)) {
          // expire the UI and redirect to purchase page
          input.disabled = true;
          sendBtn.disabled = true;
          alert("Your session has expired.");
          cleanup();
          setTimeout(() => (window.location.href = "pay.html#" + section), 1200);
        }
      }

      // cleanup function to return
      function cleanup() {
        timedOut = true;
        try { unsubSnap(); } catch (_) {}
        try { clearInterval(poll); } catch (_) {}
      }

      // Return the unsubscribe so caller can cancel (we store it into unsubscribeEnt)
      return cleanup;
    } catch (err) {
      console.error("watchExpiry init error:", err);
      // fallback: redirect immediately
      window.location.href = "pay.html#" + section;
      return () => {};
    }
  }

  function initRealtimeListenerForUser(uid) {
    const chatDocId = `${SECTION}_${uid}`; // chatId format "<section>_<uid>" matches your rules
    messagesColRef = collection(db, "chats", chatDocId, "messages");
    const q = query(messagesColRef, orderBy("timestamp", "asc"));

    if (typeof unsubscribeSnapshot === "function") unsubscribeSnapshot();

    unsubscribeSnapshot = onSnapshot(q, snapshot => {
      chatBox.innerHTML = "";
      snapshot.forEach(docSnap => renderMessageToUI(docSnap.data()));
      chatBox.scrollTop = chatBox.scrollHeight;
    }, err => console.error("Firestore listener error:", err));
  }

  function renderMessageToUI(msg) {
    const el = document.createElement("div");
    el.className = "message " + (msg.senderType === "user" ? "user" : "bot");
    if (msg.senderType === "admin") {
      const avatarName = msg.adminName || ADMIN_NAME;
      el.innerHTML = `<img src="assets/avatars/${avatarName}.png" class="avatar" />
                      <div class="bubble">${escapeHtml(msg.text)}</div>`;
    } else {
      el.innerHTML = `<div class="bubble">${escapeHtml(msg.text)}</div>`;
    }
    chatBox.appendChild(el);
  }

  document.getElementById("sendBtn").addEventListener("click", sendMessage);
  document.getElementById("userInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") sendMessage();
  });

  async function sendMessage() {
    const text = (document.getElementById("userInput").value || "").trim();
    if (!text || !currentUid || !messagesColRef) return;
    document.getElementById("userInput").value = "";

    try {
      const chatDocId = `${SECTION}_${currentUid}`;
      const chatDocRef = doc(db, "chats", chatDocId);
      await setDoc(chatDocRef, {
        section: SECTION,
        userId: currentUid,
        createdAt: serverTimestamp()
      }, { merge: true });

      await addDoc(messagesColRef, {
        text,
        senderType: "user",
        senderId: currentUid,
        timestamp: serverTimestamp()
      });

    } catch (err) {
      console.error("Firestore write error:", err);
      alert("Failed to send message ‚Äî check console for details.");
      return;
    }
  }

  function escapeHtml(str) {
    if (!str) return "";
    return str.replace(/[&<>"]/g, tag => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;'
    }[tag]));
  }
</script>
</body>
</html>
